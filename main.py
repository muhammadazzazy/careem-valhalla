# import the necessary packages
import csv
import os

from graph_id import GraphId

def read_way_edges(filepath):
    """
    Reads the way_edges.txt file and extracts the graph IDs in a dictionary

    :param filepath: The filepath to the way_edges.txt file.
    :return: A dictionary indexed by the OSM way ID and containing a tuple of the direction and the graph ID.
    """
    way_edges = {}

    with open(filepath, 'r') as file:
        for line in file:
            parts = line.strip().split(',')

            osm_way_id = parts[0]
            # print(osm_way_id)

            dirs_gph_ids = parts[1:]
            # print(dirs_gph_ids)

            # Initialize list for the current osm_way_id if not already present
            if osm_way_id not in way_edges:
                way_edges[osm_way_id] = []

            # Iterate over the graph ids, converting them to GraphId objects
            for i in range(0, len(dirs_gph_ids), 2):
                direction = dirs_gph_ids[i]
                gph_id = int(dirs_gph_ids[i + 1])

                # Create a GraphId object from the graph_id (64-bit value)
                graph_id = GraphId(value=gph_id)

                # Store (direction, GraphId) tuple in the dictionary
                way_edges[osm_way_id].append((direction, graph_id))

    return way_edges

def extract_file_names(directory, extension):
    """
    Extracts file names with a specific extension from a directory recursively.

    :param directory: The root directory to start searching.
    :param extension: The file extension to filter (e.g., '.txt', '.jpg').
    :return: A list of file paths with the specified extension.
    """
    file_names = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(extension):
                file_names.append(os.path.join(root, file))
    return file_names

def write_csv_from_gph(gph_file_paths, way_edges):
    """
    Writes CSV files with the same names as the .gph files based on the way_edges dictionary.
    Only writes to the CSV if the last 3 digits of the tile_id match the filename.

    :param gph_file_paths: List of file paths for the .gph files.
    :param way_edges: Dictionary with OSM Way ID as keys and (direction, graph_id) tuples as values.
    """
    freeflow_speed = 50
    constrained_speed = 40

    for gph_path in gph_file_paths:
        # Get directory and base filename without extension
        directory = os.path.dirname(gph_path)
        base_name = os.path.splitext(os.path.basename(gph_path))[0]

        # Set CSV output path
        csv_path = os.path.join(directory, f"{base_name}.csv")

        # Prepare to write to CSV
        with open(csv_path, mode='w', newline='') as csv_file:
            csv_writer = csv.writer(csv_file)
            # Write CSV header
            csv_writer.writerow(['edge_id', 'freeflow_speed', 'constrained_speed'])

            # Write edge data only if the condition is met
            for osm_way_id, graph_info in way_edges.items():
                # Extract the last 3 digits before the second slash
                for direction, graph_id in graph_info:
                    if '/' in str(graph_id):
                        parts = str(graph_id).split('/')
                        if len(parts[1]) == 3:
                            ValueError("Shit")
                        if len(parts) == 3 and len(parts[1]) >= 3:  # Check if there's a second part and it's long enough
                            last_three_digits = parts[1][-3:]  # Get last 3 digits before the second slash

                            if last_three_digits == base_name:  # Compare with base_name
                                edge_id = str(graph_id)  # Use graph_id as edge_id
                                csv_writer.writerow([edge_id, freeflow_speed, constrained_speed])
                                print(f"Wrote to CSV: {edge_id}")

            print(f"CSV file written to: {csv_path}")

def delete_files(directory, extension):
    """
    Recursively deletes all files with a specific extension in the specified directory and its subdirectories.

    :param directory: The root directory to start the search and deletion.
    :param extension: The extension of the files to be deleted.
    """
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(extension):
                file_path = os.path.join(root, file)
                os.remove(file_path)
                print(f"Deleted: {file_path}")




def main():
    """Main function."""
    tiles_path = "C:\\Users\\muhammadazzazy\\Desktop\\valhalla\\jordan_tiles"
    # Delete the existing traffic CSV files from the tiles directory
    delete_files(tiles_path, extension='.csv')

    # Read the way edges from the way_edges.txt which was previously generated by Valhalla
    file_path = 'way_edges.txt'
    way_edges = read_way_edges(file_path)

    print("Graph IDs read from way_edges.txt")

    for osm_way_id, graph_info in way_edges.items():
        print(f"OSM Way ID: {osm_way_id}")
        for direction, graph_id in graph_info:
            print(f"\tDirection: {direction}, GraphId: {str(graph_id)}")

    # Extract the file paths of the .gph files from the tiles directory generated by Valhalla
    file_paths = extract_file_names(tiles_path, extension=".gph")
    print("File paths:")
    print(file_paths)

    # Extract the file names of the .gph files from the extracted file paths
    file_names = []
    for file_path in file_paths:
        file_names.append(os.path.basename(file_path))
    print(file_names)

    # Write the traffic information to the CSV files according to Valhalla's file naming and directory structure
    # conventions
    write_csv_from_gph(file_paths, way_edges)
    print(f"Traffic CSV files successfully written to {tiles_path}.")

if __name__ == "__main__":
    main()
